\section{Future Work} \label{sec:futurework}
Future work for this project includes performance tuning, security analysis, and implementation of missing features.

Features that are missing include all of the block modes of operation besides the ECB mode, support for the 192b and 256b key sizes, and validation of newly implemented modes.  

Implementing the remaining block modes is intended to be relatively straightforward.  Block modes are implemented in hardware and would only need code written in the hardware Controller block to support new modes.

Support for larger key sizes would be slightly more complicated than implementing new block modes.  Key size increases would require some restructuring of variables to support a larger key size and the key scheduler block would have to be rewritten to support the 3 different modes of operation.  Key input for the decrypt and encrypt rounds, however, would be unchanged, as each round would still take a 128b input.

Validating each newly-implemented feature is a non-trivial task.  The NIST-provided test vectors provide a rich set of tests for verifying the operation of a cipher implementation.  Our implementation already complies with the NIST ECB Monte Carlo test, but verifying the CBC, OFB, etc. modes of operation as well as all tests for 192b and 256b key sizes would require custom code for each test to be written into the stimulus of our implementation.  A feature that would go along with these verifications would be an automatic 'diff' checker of our generated output against the known response files.  This, however, could be written as an external tool in a script program that would not have to interface with our SpecC implementation.

A security analysis of our implementation would be necessary before declaring the project complete and ready for reliable use in an embedded system.  A non-exhaustive set of concerns would include protecting against side-channel attacks, protection of a key in memory, and protection of between-round states of data.  
We belive that our implementation already has a reasonable level of tolerance to side-channel timing attacks because we use constant-time hardware lookup tables for many operations.  An exception to this is the Galois multiplicaiton in our encryption implementation, but this could be trivially replaced with a lookup table as we did in the corresponding inverse function.
We currently implicitly rely on the security and trust of an operating system to protect keys in memory, both in RAM and on disk.  Once a key is passed into the hardware part of our implementation, we believe that the key would be protected simply by the nature of being stored in hardware memory that would be unreasonable to tamper with or observe.  However, the software part of our implementation currently does not take any extra measures to protect a key that is in software memory.  We rely on an implicit trust of the OS running our software to protect external access to the key, an obvious point of attack that would need to be addressed.
Finally, the state of data in between cipher rounds needs to be protected.  We believe that a reasonable amount of protection is provided simply by implementing these rounds in hardware, assuming that a silicon implementation of the hardware would be dificult to tamper with.  However, if this is not the case, then additional measures would need to be taken to protect this intermediate data from tampering or observation.
